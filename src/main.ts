import core from "@actions/core";
import { Octokit } from "octokit";
import { getAdapter, type CliResult, type IssueContext } from "./adapters";

const FOOTER = "ðŸ¤– Generated by Spec Gardener";
const COMMAND_PATTERN = /\/spec-gardener(?:\s|$)/i;
const ORIGINAL_MARKER = "<details><summary>Original description</summary>";

const COMMANDS_HELP = `<details><summary>Commands</summary>

- \`/spec-gardener\` - Continue the conversation to refine this specification

</details>`;

const hasFooter = (text: string): boolean => text.includes(FOOTER);

const hasCommand = (text: string): boolean => COMMAND_PATTERN.test(text);

const extractOriginalBody = (body: string): string => {
  const markerIndex = body.indexOf(ORIGINAL_MARKER);
  if (markerIndex === -1) {
    return body;
  }
  const start = markerIndex + ORIGINAL_MARKER.length;
  const end = body.indexOf("</details>", start);
  if (end === -1) {
    return body;
  }
  return body.slice(start, end).trim();
};

const buildIssueBody = (spec: string, originalBody: string): string => {
  const original = originalBody.includes(ORIGINAL_MARKER)
    ? extractOriginalBody(originalBody)
    : originalBody;

  return `${spec}

---
${ORIGINAL_MARKER}

${original}

</details>

${FOOTER}`;
};

const buildComment = (content: string, authorLogin: string): string => {
  return `${COMMANDS_HELP}

@${authorLogin} ${content}

---
${FOOTER}`;
};

const getRequiredInput = (name: string): string => {
  return core.getInput(name, { required: true });
};

const fetchIssueContext = async (
  octokit: Octokit,
  owner: string,
  repo: string,
  issueNumber: number,
): Promise<IssueContext> => {
  const issueResponse = await octokit.rest.issues.get({
    owner,
    repo,
    issue_number: issueNumber,
  });

  const comments = await octokit.paginate(octokit.rest.issues.listComments, {
    owner,
    repo,
    issue_number: issueNumber,
    per_page: 100,
  });

  return {
    title: issueResponse.data.title ?? "",
    body: issueResponse.data.body ?? "",
    author: issueResponse.data.user?.login ?? "unknown",
    comments: comments.map((comment) => ({
      author: comment.user?.login ?? "unknown",
      body: comment.body ?? "",
      createdAt: comment.created_at ?? "",
    })),
  };
};

const runProvider = async (
  agentCommand: string,
  args: string[],
  prompt: string,
): Promise<string> => {
  const proc = Bun.spawn([agentCommand, ...args], {
    stdin: "pipe",
    stdout: "pipe",
    stderr: "pipe",
  });

  if (!proc.stdin) {
    throw new Error("Provider process stdin is not available.");
  }

  proc.stdin.write(prompt);
  proc.stdin.end();

  const stdoutPromise = new Response(proc.stdout).text();
  const stderrPromise = new Response(proc.stderr).text();
  const exitCode = await proc.exited;
  const stdout = await stdoutPromise;
  const stderr = await stderrPromise;

  if (exitCode !== 0) {
    throw new Error(`Provider exited with code ${exitCode}: ${stderr}`);
  }

  if (stderr.trim()) {
    core.info(`Provider stderr: ${stderr.trim()}`);
  }

  return stdout;
};

const applyResult = async (
  octokit: Octokit,
  owner: string,
  repo: string,
  issueNumber: number,
  result: CliResult,
  issueContext: IssueContext,
): Promise<void> => {
  if (result.type === "question") {
    const comment = buildComment(result.content, issueContext.author);
    await octokit.rest.issues.createComment({
      owner,
      repo,
      issue_number: issueNumber,
      body: comment,
    });
    return;
  }

  const newBody = buildIssueBody(result.body, issueContext.body);
  await octokit.rest.issues.update({
    owner,
    repo,
    issue_number: issueNumber,
    body: newBody,
  });

  const summaryComment = buildComment(
    result.comment ?? "Specification has been updated.",
    issueContext.author,
  );
  await octokit.rest.issues.createComment({
    owner,
    repo,
    issue_number: issueNumber,
    body: summaryComment,
  });
};

type EventPayload = {
  issue?: { number?: number; body?: string };
  comment?: { body?: string };
};

const shouldProcess = (
  eventName: string,
  event: EventPayload,
): { shouldRun: boolean; reason?: string } => {
  if (eventName === "issue_comment") {
    const commentBody = event.comment?.body ?? "";
    if (hasFooter(commentBody)) {
      return {
        shouldRun: false,
        reason: "Skipping: comment generated by Spec Gardener.",
      };
    }
    if (!hasCommand(commentBody)) {
      return {
        shouldRun: false,
        reason: "Skipping: comment does not contain /spec-gardener command.",
      };
    }
    return { shouldRun: true };
  }

  // For issues events (opened, edited, labeled, etc.)
  const issueBody = event.issue?.body ?? "";
  if (hasFooter(issueBody)) {
    return {
      shouldRun: false,
      reason: "Skipping: issue body already contains Spec Gardener footer.",
    };
  }

  return { shouldRun: true };
};

export const main = async (): Promise<void> => {
  try {
    const agent = getRequiredInput("agent");
    const token = getRequiredInput("github_token");

    const repoSlug = process.env.GITHUB_REPOSITORY ?? "";
    const [owner, repo] = repoSlug.split("/");
    if (!owner || !repo) {
      throw new Error("Unable to resolve repository owner/name.");
    }

    const eventPath = process.env.GITHUB_EVENT_PATH ?? "";
    if (!eventPath) {
      throw new Error("Missing GITHUB_EVENT_PATH.");
    }

    const eventName = process.env.GITHUB_EVENT_NAME ?? "";
    const event = JSON.parse(await Bun.file(eventPath).text()) as EventPayload;

    const { shouldRun, reason } = shouldProcess(eventName, event);
    if (!shouldRun) {
      core.info(reason ?? "Skipping processing.");
      return;
    }

    const issueNumber = event.issue?.number;
    if (!issueNumber) {
      throw new Error("Missing issue number in event payload.");
    }

    const octokit = new Octokit({ auth: token });
    const issueContext = await fetchIssueContext(
      octokit,
      owner,
      repo,
      issueNumber,
    );

    const adapter = getAdapter(agent);
    const prompt = adapter.buildPrompt(issueContext);
    const output = await runProvider(agent, adapter.buildArgs(), prompt);
    const result = adapter.parseOutput(output);

    await applyResult(octokit, owner, repo, issueNumber, result, issueContext);
  } catch (error) {
    const message = error instanceof Error ? error.message : "Unknown error";
    core.setFailed(message);
  }
};
