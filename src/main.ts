import core from "@actions/core";
import { Octokit } from "octokit";
import { getAdapter, type CliResult, type SpecContext } from "./adapters";

const FOOTER = "ðŸ¤– Generated by Spec Gardener";
const COMMAND_PATTERN = /\/spec-gardener(?:\s+(reset|help))?\b/i;
const DEFAULT_AGENT_TIMEOUT_MS = 120000;
const THUMBS_UP_REACTION = "+1";

const COMMANDS_HINT = "ðŸ’¡ Type `/spec-gardener help` for available commands";

const COMMANDS_LIST = [
  "- `/spec-gardener` - Continue the conversation to refine this specification",
  "- `/spec-gardener reset` - Re-analyze from the original description and comments from the reset point onward",
  "- `/spec-gardener help` - Show available commands",
].join("\n");

type CommentCommand = "continue" | "reset" | "help";

const hasFooter = (text: string): boolean => text.includes(FOOTER);

const parseCommand = (text: string): CommentCommand | null => {
  const match = COMMAND_PATTERN.exec(text);
  if (!match) {
    return null;
  }
  const subcommand = match[1]?.toLowerCase();
  switch (subcommand) {
    case "reset":
      return "reset";
    case "help":
      return "help";
    default:
      return "continue";
  }
};

const stripFooter = (body: string): string => {
  const footerIndex = body.indexOf(FOOTER);
  if (footerIndex === -1) {
    return body;
  }
  const withoutFooter = body.slice(0, footerIndex).trimEnd();
  return withoutFooter.replace(/\n---\s*$/, "").trimEnd();
};

const applyResetContext = (context: SpecContext, resetCreatedAt?: string): SpecContext => {
  if (!resetCreatedAt) {
    return context;
  }
  const resetTime = Date.parse(resetCreatedAt);
  if (Number.isNaN(resetTime)) {
    return context;
  }
  return {
    ...context,
    body: context.originalDescription,
    comments: context.comments.filter((comment) => {
      const commentTime = Date.parse(comment.createdAt);
      if (Number.isNaN(commentTime)) {
        return false;
      }
      return commentTime >= resetTime;
    }),
  };
};

const buildSpecBody = (spec: string): string => {
  return `${spec}

---
${FOOTER}`;
};

const buildComment = (content: string, authorLogin: string): string => {
  return `@${authorLogin} ${content}

---
${COMMANDS_HINT}
${FOOTER}`;
};

const buildHelpComment = (): string => {
  return `${COMMANDS_LIST}

---
${FOOTER}`;
};

const normalizeTitle = (title: string): string => {
  return title.replace(/\s+/g, " ").trim();
};

const buildErrorComment = (runUrl: string): string => {
  return `Spec Gardener encountered an error while processing this issue.

Please check the workflow run for details:
${runUrl}

---
${COMMANDS_HINT}
${FOOTER}`;
};

const postErrorComment = async (
  owner: string,
  repo: string,
  issueNumber: number,
  token: string,
): Promise<void> => {
  try {
    const serverUrl = process.env.GITHUB_SERVER_URL ?? "https://github.com";
    const runId = process.env.GITHUB_RUN_ID ?? "";
    const runUrl = runId
      ? `${serverUrl}/${owner}/${repo}/actions/runs/${runId}`
      : `${serverUrl}/${owner}/${repo}/actions`;
    const octokit = new Octokit({ auth: token });
    await octokit.rest.issues.createComment({
      owner,
      repo,
      issue_number: issueNumber,
      body: buildErrorComment(runUrl),
    });
  } catch (commentError) {
    const fallback =
      commentError instanceof Error
        ? (commentError.stack ?? commentError.message)
        : "Unknown error";
    core.error(`Failed to post error comment: ${fallback}`);
  }
};

const getRequiredInput = (name: string): string => {
  return core.getInput(name, { required: true });
};

const getTimeoutInput = (name: string, fallbackMs: number): number => {
  const raw = core.getInput(name);
  if (!raw.trim()) {
    return fallbackMs;
  }
  const parsed = Number.parseInt(raw, 10);
  if (Number.isNaN(parsed) || parsed <= 0) {
    core.warning(`Invalid ${name} value "${raw}", falling back to ${fallbackMs}ms.`);
    return fallbackMs;
  }
  return parsed;
};

type UserContentEditsResponse = {
  repository?: {
    issue?: {
      userContentEdits?: { nodes?: Array<{ body?: string | null }> };
    };
    pullRequest?: {
      userContentEdits?: { nodes?: Array<{ body?: string | null }> };
    };
  };
};

const fetchOriginalDescription = async (
  octokit: Octokit,
  owner: string,
  repo: string,
  number: number,
  itemType: "issue" | "pullRequest",
  fallbackBody: string,
): Promise<string> => {
  try {
    const response = await octokit.graphql<UserContentEditsResponse>(
      `query($owner: String!, $repo: String!, $number: Int!) {
        repository(owner: $owner, name: $repo) {
          ${itemType}(number: $number) {
            userContentEdits(first: 1) {
              nodes {
                body
              }
            }
          }
        }
      }`,
      { owner, repo, number },
    );
    const originalFromEdits =
      itemType === "issue"
        ? response.repository?.issue?.userContentEdits?.nodes?.[0]?.body
        : response.repository?.pullRequest?.userContentEdits?.nodes?.[0]?.body;
    if (originalFromEdits) {
      return originalFromEdits;
    }
  } catch (error) {
    const message = error instanceof Error ? (error.message ?? error.stack) : String(error);
    const label = itemType === "issue" ? "issue description" : "pull request description";
    core.warning(`Failed to fetch original ${label}: ${message}`);
  }
  return fallbackBody;
};

const fetchIssueContext = async (
  octokit: Octokit,
  owner: string,
  repo: string,
  issueNumber: number,
): Promise<SpecContext> => {
  const issueResponse = await octokit.rest.issues.get({
    owner,
    repo,
    issue_number: issueNumber,
  });
  const issueBody = issueResponse.data.body ?? "";
  const originalDescription = await fetchOriginalDescription(
    octokit,
    owner,
    repo,
    issueNumber,
    "issue",
    issueBody,
  );

  const comments = await octokit.paginate(octokit.rest.issues.listComments, {
    owner,
    repo,
    issue_number: issueNumber,
    per_page: 100,
  });

  return {
    title: issueResponse.data.title ?? "",
    body: stripFooter(issueBody),
    author: issueResponse.data.user?.login ?? "unknown",
    originalDescription,
    comments: comments.map((comment) => ({
      author: comment.user?.login ?? "unknown",
      body: comment.body ?? "",
      createdAt: comment.created_at ?? "",
    })),
  };
};

const fetchPullRequestContext = async (
  octokit: Octokit,
  owner: string,
  repo: string,
  pullNumber: number,
): Promise<SpecContext> => {
  const pullResponse = await octokit.rest.pulls.get({
    owner,
    repo,
    pull_number: pullNumber,
  });
  const pullBody = pullResponse.data.body ?? "";
  const originalDescription = await fetchOriginalDescription(
    octokit,
    owner,
    repo,
    pullNumber,
    "pullRequest",
    pullBody,
  );

  const comments = await octokit.paginate(octokit.rest.issues.listComments, {
    owner,
    repo,
    issue_number: pullNumber,
    per_page: 100,
  });

  const files = await octokit.paginate(octokit.rest.pulls.listFiles, {
    owner,
    repo,
    pull_number: pullNumber,
    per_page: 100,
  });

  return {
    title: pullResponse.data.title ?? "",
    body: stripFooter(pullBody),
    author: pullResponse.data.user?.login ?? "unknown",
    originalDescription,
    comments: comments.map((comment) => ({
      author: comment.user?.login ?? "unknown",
      body: comment.body ?? "",
      createdAt: comment.created_at ?? "",
    })),
    changedFiles: files.map((file) => ({
      filename: file.filename,
      status: file.status,
      additions: file.additions,
      deletions: file.deletions,
      changes: file.changes,
    })),
  };
};

const runProvider = async (
  cmd: string,
  args: string[],
  prompt: string,
  timeoutMs: number,
): Promise<string> => {
  const cwd = process.env.GITHUB_WORKSPACE ?? process.cwd();
  core.info(`Running: ${cmd} ${args.join(" ")} (cwd: ${cwd})`);

  const proc = Bun.spawn([cmd, ...args, prompt], {
    cwd,
    stdout: "pipe",
    stderr: "pipe",
  });

  if (!proc.stdout || typeof proc.stdout === "number") {
    throw new Error("Provider process stdout is not available.");
  }
  if (!proc.stderr || typeof proc.stderr === "number") {
    throw new Error("Provider process stderr is not available.");
  }

  let timeoutId: ReturnType<typeof setTimeout> | undefined;
  const execute = async (): Promise<string> => {
    const stdoutPromise = new Response(proc.stdout).text();
    const stderrPromise = new Response(proc.stderr).text();
    const exitCode = await proc.exited;
    const stdout = await stdoutPromise;
    const stderr = await stderrPromise;

    if (exitCode !== 0) {
      throw new Error(`Provider exited with code ${exitCode}: ${stderr}`);
    }

    if (stderr.trim()) {
      core.info(`Provider stderr: ${stderr.trim()}`);
    }

    return stdout;
  };

  try {
    if (timeoutMs > 0) {
      const executionPromise = execute();
      // Suppress expected rejection if the timeout wins the race.
      executionPromise.catch(() => undefined);
      const timeoutPromise = new Promise<never>((_, reject) => {
        timeoutId = setTimeout(() => {
          proc.kill();
          reject(new Error(`Provider timed out after ${timeoutMs}ms.`));
        }, timeoutMs);
      });
      return await Promise.race([executionPromise, timeoutPromise]);
    }
    return await execute();
  } finally {
    if (timeoutId) {
      clearTimeout(timeoutId);
    }
  }
};

const applyResult = async (
  octokit: Octokit,
  owner: string,
  repo: string,
  issueNumber: number,
  result: CliResult,
  specContext: SpecContext,
): Promise<void> => {
  if (result.type === "no_change") {
    await octokit.rest.reactions.createForIssue({
      owner,
      repo,
      issue_number: issueNumber,
      content: THUMBS_UP_REACTION,
    });
    return;
  }
  if (result.type === "question") {
    const comment = buildComment(result.content, specContext.author);
    await octokit.rest.issues.createComment({
      owner,
      repo,
      issue_number: issueNumber,
      body: comment,
    });
    return;
  }

  const newBody = buildSpecBody(result.body);
  const updateParams: {
    owner: string;
    repo: string;
    issue_number: number;
    body: string;
    title?: string;
  } = {
    owner,
    repo,
    issue_number: issueNumber,
    body: newBody,
  };
  if (result.title) {
    const normalizedTitle = normalizeTitle(result.title);
    const currentTitle = normalizeTitle(specContext.title);
    if (normalizedTitle && normalizedTitle !== currentTitle) {
      updateParams.title = normalizedTitle;
    }
  }
  await octokit.rest.issues.update(updateParams);

  const summaryComment = buildComment(
    result.comment ?? "Specification has been updated.",
    specContext.author,
  );
  await octokit.rest.issues.createComment({
    owner,
    repo,
    issue_number: issueNumber,
    body: summaryComment,
  });
};

type EventPayload = {
  issue?: { number?: number; body?: string; pull_request?: object };
  pull_request?: { number?: number; body?: string };
  comment?: { body?: string; created_at?: string };
};

const shouldProcess = (
  eventName: string,
  event: EventPayload,
): {
  shouldRun: boolean;
  reason?: string;
  command?: CommentCommand;
  commandCreatedAt?: string;
} => {
  if (eventName === "issue_comment") {
    const commentBody = event.comment?.body ?? "";
    if (hasFooter(commentBody)) {
      return {
        shouldRun: false,
        reason: "Skipping: comment generated by Spec Gardener.",
      };
    }
    const command = parseCommand(commentBody);
    if (!command) {
      return {
        shouldRun: false,
        reason: "Skipping: comment does not contain /spec-gardener command.",
      };
    }
    return {
      shouldRun: true,
      command,
      commandCreatedAt: event.comment?.created_at,
    };
  }

  if (eventName === "pull_request") {
    const pullBody = event.pull_request?.body ?? "";
    if (hasFooter(pullBody)) {
      return {
        shouldRun: false,
        reason: "Skipping: pull request body already contains Spec Gardener footer.",
      };
    }
    return { shouldRun: true };
  }

  // For issues events (opened, edited, labeled, etc.)
  const issueBody = event.issue?.body ?? "";
  if (hasFooter(issueBody)) {
    return {
      shouldRun: false,
      reason: "Skipping: issue body already contains Spec Gardener footer.",
    };
  }

  return { shouldRun: true };
};

export const main = async (): Promise<void> => {
  let owner = "";
  let repo = "";
  let issueNumber: number | undefined;
  let token = "";
  try {
    const agent = getRequiredInput("agent");
    token = getRequiredInput("github_token");
    const timeoutMs = getTimeoutInput("agent_timeout_ms", DEFAULT_AGENT_TIMEOUT_MS);
    const customPrompt = core.getInput("custom_prompt");

    const repoSlug = process.env.GITHUB_REPOSITORY ?? "";
    [owner, repo] = repoSlug.split("/");
    if (!owner || !repo) {
      throw new Error("Unable to resolve repository owner/name.");
    }

    const eventPath = process.env.GITHUB_EVENT_PATH ?? "";
    if (!eventPath) {
      throw new Error("Missing GITHUB_EVENT_PATH.");
    }

    const eventName = process.env.GITHUB_EVENT_NAME ?? "";
    const event = JSON.parse(await Bun.file(eventPath).text()) as EventPayload;

    const { shouldRun, reason, command, commandCreatedAt } = shouldProcess(eventName, event);
    if (!shouldRun) {
      core.info(reason ?? "Skipping processing.");
      return;
    }

    const isPullRequestEvent = eventName === "pull_request" || Boolean(event.issue?.pull_request);
    issueNumber = event.pull_request?.number ?? event.issue?.number;
    if (!issueNumber) {
      throw new Error("Missing issue number in event payload.");
    }

    const octokit = new Octokit({ auth: token });
    if (command === "help") {
      await octokit.rest.issues.createComment({
        owner,
        repo,
        issue_number: issueNumber,
        body: buildHelpComment(),
      });
      return;
    }
    const specContext = isPullRequestEvent
      ? await fetchPullRequestContext(octokit, owner, repo, issueNumber)
      : await fetchIssueContext(octokit, owner, repo, issueNumber);
    const adjustedContext =
      command === "reset" ? applyResetContext(specContext, commandCreatedAt) : specContext;
    const adapter = getAdapter(agent);
    const { cmd, args } = adapter.buildCommand();
    const prompt = adapter.buildPrompt(adjustedContext, customPrompt);
    const output = await runProvider(cmd, args, prompt, timeoutMs);
    core.info(`Raw agent output:\n${output}`);
    const { result, parseFailed } = adapter.parseOutput(output);
    if (parseFailed) {
      core.error(`Failed to parse agent output as JSON.`);
    }

    await applyResult(octokit, owner, repo, issueNumber, result, adjustedContext);
  } catch (error) {
    const message = error instanceof Error ? (error.stack ?? error.message) : "Unknown error";
    if (owner && repo && issueNumber && token) {
      await postErrorComment(owner, repo, issueNumber, token);
    }
    core.setFailed(message);
  }
};
